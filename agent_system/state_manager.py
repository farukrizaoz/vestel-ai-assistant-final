"""
State Management - Konu≈üma ge√ßmi≈üi ve session y√∂netimi
"""
import json
import uuid
from datetime import datetime
from pathlib import Path
from typing import Dict, List

from agent_system.config import PROJECT_ROOT
from agent_system.session_db import session_db

# Session dosyalarƒ± i√ßin klas√∂r
SESSIONS_DIR = Path(PROJECT_ROOT) / "sessions"
SESSIONS_DIR.mkdir(exist_ok=True)

class ConversationManager:
    """Konu≈üma durumunu y√∂netir"""
    
    def __init__(self, session_id: str = None):
        self.session_id = session_id or str(uuid.uuid4())
        self.sessions_dir = SESSIONS_DIR
        self.session_file = SESSIONS_DIR / f"{self.session_id}.json"
        self.conversation_history = []
        self.current_products = []
        self.load_session()
        
        # DB'ye session kaydƒ± olu≈ütur
        session_db.create_session(self.session_id)
    
    def load_session(self):
        """Oturum verilerini y√ºkle"""
        if self.session_file.exists():
            try:
                with open(self.session_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                    self.conversation_history = data.get('history', [])
                    self.current_products = data.get('products', [])
            except:
                # Dosya bozuksa yeni ba≈üla
                self.conversation_history = []
                self.current_products = []
    
    def save_session(self):
        """Oturum verilerini kaydet"""
        # Eƒüer session dosyasƒ± mevcutsa created_at'i koru
        created_at = datetime.now().isoformat()
        if self.session_file.exists():
            try:
                with open(self.session_file, 'r', encoding='utf-8') as f:
                    existing_data = json.load(f)
                    created_at = existing_data.get('created_at', created_at)
            except:
                pass  # Hata durumunda yeni tarih kullan
        
        data = {
            'session_id': self.session_id,
            'created_at': created_at,
            'last_activity': datetime.now().isoformat(),
            'history': self.conversation_history,
            'products': self.current_products,
            'metadata': {
                'message_count': len(self.conversation_history),
                'product_count': len(self.current_products)
            }
        }
        with open(self.session_file, 'w', encoding='utf-8') as f:
            json.dump(data, f, ensure_ascii=False, indent=2)
        
        # DB'yi g√ºncelle
        session_db.update_session_activity(
            self.session_id,
            len(self.conversation_history),
            len(self.current_products)
        )
    
    def create_session(self, session_id: str = None):
        """Yeni session olu≈ütur"""
        if session_id:
            self.session_id = session_id
        else:
            self.session_id = str(uuid.uuid4())
        
        self.session_file = SESSIONS_DIR / f"{self.session_id}.json"
        self.conversation_history = []
        self.current_products = []
        self.save_session()
        
        # DB'ye kaydet
        session_db.create_session(self.session_id)
        
        return self.session_id
    
    def add_message(self, session_id: str, sender: str, content: str):
        """Belirli session'a mesaj ekle"""
        if session_id != self.session_id:
            # Farklƒ± session ise y√ºkle
            self.session_id = session_id
            self.session_file = SESSIONS_DIR / f"{self.session_id}.json"
            self.load_session()
        
        # Akƒ±llƒ± duplike mesaj kontrol√º - sadece 5 saniye i√ßinde aynƒ± mesaj g√∂nderilirse engelleyelim
        if self.conversation_history:
            last_message = self.conversation_history[-1]
            if (last_message['sender'] == sender and 
                last_message['content'] == content):
                # Son mesajƒ±n zamanƒ±nƒ± kontrol et
                try:
                    last_time = datetime.fromisoformat(last_message['timestamp'])
                    current_time = datetime.now()
                    time_diff = (current_time - last_time).total_seconds()
                    
                    # Sadece 5 saniye i√ßinde aynƒ± mesaj g√∂nderilirse engelle
                    if time_diff < 5:
                        print(f"‚ö†Ô∏è Duplike mesaj tespit edildi (5sn i√ßinde), eklenmedi: {sender}: {content[:50]}...")
                        return
                except Exception as e:
                    # Timestamp parse hatasƒ± durumunda devam et
                    print(f"‚ö†Ô∏è Timestamp parse hatasƒ±: {e}")
                    pass
        
        message = {
            'timestamp': datetime.now().isoformat(),
            'sender': sender,
            'content': content
        }
        self.conversation_history.append(message)
        self.save_session()
    
    def get_conversation_history(self, session_id: str = None):
        """Belirli session'ƒ±n konu≈üma ge√ßmi≈üini al"""
        if session_id and session_id != self.session_id:
            # Ge√ßici olarak o session'ƒ± y√ºkle
            temp_file = SESSIONS_DIR / f"{session_id}.json"
            if temp_file.exists():
                try:
                    with open(temp_file, 'r', encoding='utf-8') as f:
                        data = json.load(f)
                        return data.get('history', [])
                except:
                    return []
            return []
        return self.conversation_history
    
    def add_products(self, products: list):
        """Bulunan √ºr√ºnleri kaydet"""
        self.current_products.extend(products)
        self.save_session()
    
    def clear_products(self):
        """√úr√ºn listesini temizle"""
        self.current_products = []
        self.save_session()
    
    def get_context(self) -> str:
        """Son konu≈üma baƒülamƒ±nƒ± al"""
        if not self.conversation_history:
            return "Yeni konu≈üma."
        
        recent = self.conversation_history[-3:]
        context = "Son konu≈üma:\n"
        for msg in recent:
            role = "üë§" if msg['sender'] == 'user' else "ü§ñ"
            content = msg['content'][:100] + "..." if len(msg['content']) > 100 else msg['content']
            context += f"{role} {content}\n"
        return context
    
    def get_detailed_context(self) -> str:
        """Detaylƒ± konu≈üma baƒülamƒ±nƒ± al - product memory dahil"""
        context = ""
        
        # Son 5 mesajƒ± al
        if self.conversation_history:
            recent = self.conversation_history[-5:]
            context += "üìã Konu≈üma Ge√ßmi≈üi:\n"
            for msg in recent:
                role = "üë§" if msg['sender'] == 'user' else "ü§ñ"
                content = msg['content'][:150] + "..." if len(msg['content']) > 150 else msg['content']
                context += f"{role} {content}\n"
            context += "\n"
        
        # Akdaki √ºr√ºnleri ekle
        if self.current_products:
            context += "üõçÔ∏è Session'da Bahsedilen √úr√ºnler:\n"
            for product in self.current_products[-3:]:  # Son 3 √ºr√ºn
                context += f"‚Ä¢ {product.get('name', 'Bilinmeyen √ºr√ºn')}\n"
            context += "\n"
        
        # Product intent memory - √úr√ºn se√ßimi detect et
        mentioned_products = self.extract_mentioned_products()
        if mentioned_products:
            context += "üéØ Kullanƒ±cƒ±nƒ±n ƒ∞lgilendiƒüi √úr√ºnler:\n"
            for product in mentioned_products[-2:]:  # Son 2 ilgi
                context += f"‚Ä¢ {product}\n"
            context += "\n"
        
        return context if context else "Yeni konu≈üma ba≈ülƒ±yor."
    
    def extract_mentioned_products(self) -> List[str]:
        """Konu≈ümalardan bahsedilen √ºr√ºnleri √ßƒ±kar"""
        mentioned = []
        keywords = ['buzdolabƒ±', 'fƒ±rƒ±n', '√ßama≈üƒ±r makinesi', 'televizyon', 'tv', 'mikrodalga', 'dishwasher', 'bula≈üƒ±k makinesi']
        
        for msg in self.conversation_history:
            if msg['sender'] == 'user':
                content = msg['content'].lower()
                for keyword in keywords:
                    if keyword in content:
                        mentioned.append(keyword.title())
                        break
        
        return list(set(mentioned))  # Unique products
    
    def add_product_context(self, product_name: str, product_details: dict = None):
        """√úr√ºn context'ini ekle - session memory i√ßin"""
        product_info = {
            'name': product_name,
            'timestamp': datetime.now().isoformat(),
            'details': product_details or {}
        }
        
        # √úr√ºn√º current_products'a ekle
        self.current_products.append(product_info)
        
        # Son 5 √ºr√ºn√º tut
        if len(self.current_products) > 5:
            self.current_products = self.current_products[-5:]
        
        self.save_session()
    
    def get_last_mentioned_product(self) -> str:
        """Son bahsedilen √ºr√ºn√º al"""
        if self.current_products:
            return self.current_products[-1].get('name', '')
        
        # History'den de bak
        mentioned = self.extract_mentioned_products()
        return mentioned[-1] if mentioned else ''
    
    def rename_session(self, session_id: str, new_name: str) -> bool:
        """Session adƒ±nƒ± deƒüi≈ütir"""
        return session_db.rename_session(session_id, new_name)
    
    def get_session_info(self, session_id: str):
        """Session bilgilerini al"""
        # DB'den meta bilgileri al
        db_info = session_db.get_session_info(session_id)
        
        # JSON dosyasƒ±ndan konu≈üma ge√ßmi≈üini al
        history = self.get_conversation_history(session_id)
        
        # Products'larƒ± al
        temp_file = SESSIONS_DIR / f"{session_id}.json"
        products = []
        if temp_file.exists():
            try:
                with open(temp_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                    products = data.get('products', [])
            except:
                pass
        
        if db_info:
            return {
                **db_info,
                'history': history,
                'products': products
            }
        
        return {
            'session_id': session_id,
            'session_name': f"Chat {session_id[:8]}",
            'created_at': 'Bilinmiyor',
            'last_activity': 'Bilinmiyor',
            'message_count': len(history),
            'product_count': len(products),
            'history': history,
            'products': products
        }
    
    @staticmethod
    def list_sessions() -> List[Dict]:
        """T√ºm oturumlarƒ± listele"""
        return session_db.list_all_sessions()

# Global session cache
_session_cache = {}

def get_conversation_manager(session_id: str = None):
    """Global conversation manager'ƒ± al veya olu≈ütur - session cache ile"""
    global _session_cache
    
    # Default session
    if session_id is None:
        session_id = "default"
    
    # Cache'den kontrol et
    if session_id in _session_cache:
        manager = _session_cache[session_id]
        # Session file'ƒ± tekrar y√ºkle (persistence i√ßin)
        manager.load_session()
        return manager
    
    # Yeni manager olu≈ütur ve cache'e ekle
    manager = ConversationManager(session_id)
    _session_cache[session_id] = manager
    
    # Cache boyutunu sƒ±nƒ±rla (son 10 session)
    if len(_session_cache) > 10:
        # En eski session'ƒ± sil
        oldest_session = next(iter(_session_cache))
        del _session_cache[oldest_session]
    
    return manager

def hydrate_sessions_from_disk() -> int:
    """
    sessions/ klas√∂r√ºndeki JSON dosyalarƒ±nƒ± tarar,
    DB'de kaydƒ± olmayanlarƒ± ekler ve metadata/saya√ßlarƒ± senkronize eder.
    D√∂n√º≈ü: eklenen/g√ºncellenen kayƒ±t sayƒ±sƒ±
    """
    added_or_updated = 0
    if not SESSIONS_DIR.exists():
        return 0
        
    for json_path in SESSIONS_DIR.glob("*.json"):
        try:
            with open(json_path, "r", encoding="utf-8") as f:
                data = json.load(f)
            
            sid = data.get("session_id") or json_path.stem
            created_at = data.get("created_at") or datetime.now().isoformat()
            last_activity = data.get("last_activity") or created_at
            history = data.get("history", [])
            products = data.get("products", [])
            metadata = data.get("metadata", {})
            session_name = metadata.get("session_name")

            # DB'de var mƒ±?
            row = session_db.get_session_info(sid)
            if not row:
                # Yoksa olu≈ütur
                session_db.create_session(sid, session_name)
                added_or_updated += 1

            # Aktivite ve saya√ßlarƒ± senkronize et
            session_db.update_session_activity(
                sid,
                message_count=len(history),
                product_count=len(products),
                last_activity=last_activity
            )

            # ƒ∞sim senkronizasyonu (eƒüer JSON'da varsa ve DB'dekinden farklƒ±ysa)
            if session_name and (not row or row.get('session_name') != session_name):
                session_db.rename_session(sid, session_name)
                if not row: # Zaten eklendi sayƒ±ldƒ±
                    pass
                else:
                    added_or_updated +=1

        except Exception as e:
            print(f"[hydrate] {json_path.name} senkronize edilemedi: {e}")
            
    return added_or_updated
